import {
  CommonSymptom,
  GeminiResponse,
  SymptomAnalysis,
  TranslationResponse
} from '@/lib/types/symptom-checker'

export const COMMON_SYMPTOMS: CommonSymptom[] = [
  { english: "Fever", hindi: "बुखार" },
  { english: "Cough", hindi: "खांसी" },
  { english: "Headache", hindi: "सिरदर्द" },
  { english: "Fatigue", hindi: "थकान" },
  { english: "Sore Throat", hindi: "गले में खराश" },
  { english: "Shortness of Breath", hindi: "सांस लेने में कठिनाई" },
  { english: "Nausea", hindi: "जी मिचलाना" },
  { english: "Diarrhea", hindi: "दस्त" }
]

export const GEMINI_API_KEY = process.env.NEXT_PUBLIC_GEMINI_API_KEY || ""

// Helper function to test API connectivity
export async function testApiConnection(): Promise<boolean> {
  try {
    const testResponse = await callGeminiApi("Say hello", undefined, 50)
    return testResponse.trim().length > 0
  } catch (error) {
    console.error("API connection test failed:", error)
    return false
  }
}

// Helper function to ensure response is within character limit
function truncateResponse(text: string, maxLength: number = 1000): string {
  if (text.length <= maxLength) {
    return text
  }
  
  // Try to truncate at a sentence boundary
  const truncated = text.substring(0, maxLength)
  const lastSentence = truncated.lastIndexOf('.')
  const lastExclamation = truncated.lastIndexOf('!')
  const lastQuestion = truncated.lastIndexOf('?')
  
  const lastPunctuation = Math.max(lastSentence, lastExclamation, lastQuestion)
  
  if (lastPunctuation > maxLength * 0.8) {
    return truncated.substring(0, lastPunctuation + 1)
  }
  
  // If no good sentence boundary, truncate at word boundary
  const lastSpace = truncated.lastIndexOf(' ')
  if (lastSpace > maxLength * 0.9) {
    return truncated.substring(0, lastSpace) + '...'
  }
  
  return truncated + '...'
}

export async function callGeminiApi(
  prompt: string, 
  systemInstruction?: string,
  maxOutputTokens: number = 400
): Promise<string> {
  // Validate API key
  if (!GEMINI_API_KEY) {
    throw new Error("Gemini API key is not configured. Please check your environment variables.")
  }

  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`
  
  const payload: any = {
    contents: [{ parts: [{ text: prompt }] }],
    generationConfig: {
      maxOutputTokens: maxOutputTokens,
      temperature: 0.7,
      topP: 0.8,
      topK: 40
    }
  }
  
  if (systemInstruction) {
    payload.systemInstruction = { parts: [{ text: systemInstruction }] }
  }

  let retries = 3
  let delay = 1000
  
  while (retries > 0) {
    try {
      // Add timeout to prevent hanging requests
      const controller = new AbortController()
      const timeoutId = setTimeout(() => controller.abort(), 30000) // 30 second timeout

      const response = await fetch(apiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
        signal: controller.signal
      })

      clearTimeout(timeoutId)

      if (!response.ok) {
        const errorBody = await response.text()
        console.error("API Error Response:", errorBody)
        
        // Handle specific error cases
        if (response.status === 429) {
          throw new Error("API rate limit exceeded. Please try again later.")
        } else if (response.status === 403) {
          throw new Error("API access forbidden. Please check your API key.")
        } else if (response.status >= 500) {
          throw new Error("API server error. Please try again later.")
        }
        
        throw new Error(`API call failed with status: ${response.status}`)
      }

      const result: GeminiResponse = await response.json()
      
      // More robust response validation
      if (!result.candidates || result.candidates.length === 0) {
        console.error("No candidates in API response:", JSON.stringify(result, null, 2))
        throw new Error("No content generated by the AI. Please try rephrasing your symptoms.")
      }

      const candidate = result.candidates[0]
      if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
        console.error("Invalid candidate structure:", JSON.stringify(candidate, null, 2))
        throw new Error("Invalid response structure from AI.")
      }

      const text = candidate.content.parts[0].text
      
      if (text && text.trim()) {
        return text // Return full response without truncation
      } else {
        console.error("Empty text response from API:", JSON.stringify(result, null, 2))
        throw new Error("AI returned empty response. Please try again.")
      }
    } catch (error) {
      console.warn(`API call failed. Retries remaining: ${retries - 1}`, error)
      retries--
      
      // Don't retry certain errors
      if (error instanceof Error) {
        if (error.message.includes("API key") || 
            error.message.includes("forbidden") || 
            error.message.includes("rate limit")) {
          throw error
        }
      }
      
      if (retries === 0) {
        if (error instanceof Error && error.name === 'AbortError') {
          throw new Error("Request timed out. Please check your internet connection and try again.")
        }
        throw new Error("Failed to get a response from the AI after multiple attempts. Please try again later.")
      }
      
      await new Promise(res => setTimeout(res, delay))
      delay = Math.min(delay * 2, 10000) // Cap delay at 10 seconds
    }
  }
  
  throw new Error("Unexpected error in API call")
}

export async function translateAndAnalyzeSymptoms(
  combinedSymptoms: string
): Promise<SymptomAnalysis> {
  // Step 1: Translate to English and detect language
  const translationPrompt = `Identify the language of the following text and then translate it to English. Respond ONLY with a valid JSON object like this: {"language": "language_name", "translation": "english_text"}. Text: "${combinedSymptoms}"`
  
  let translationResponse: string
  let language: string
  let translation: string

  try {
    translationResponse = await callGeminiApi(translationPrompt)
    
    // More robust JSON extraction
    const jsonStringMatch = translationResponse.match(/\{[\s\S]*\}/)
    
    if (!jsonStringMatch) {
      console.warn("No JSON found in translation response, attempting fallback parsing")
      // Fallback: assume English if no JSON is found
      language = "English"
      translation = combinedSymptoms
    } else {
      try {
        const parsed: TranslationResponse = JSON.parse(jsonStringMatch[0])
        language = parsed.language || "English"
        translation = parsed.translation || combinedSymptoms
      } catch (parseError) {
        console.warn("JSON parsing failed, using fallback:", parseError)
        // Fallback: assume English if JSON parsing fails
        language = "English"
        translation = combinedSymptoms
      }
    }
  } catch (error) {
    console.warn("Translation step failed, proceeding with original text:", error)
    // Fallback: assume English and use original text
    language = "English"
    translation = combinedSymptoms
  }

  // Step 2: Analyze symptoms directly in the detected language
  let systemInstruction: string
  let analysisPrompt: string
  
  if (language === "English" || language === "en") {
    systemInstruction = "You are a helpful AI Symptom Checker assistant. Your purpose is to provide general health information. You are NOT a doctor and MUST NOT provide a diagnosis. Always begin your response with a clear, bold disclaimer: '**Disclaimer: This is not medical advice. Please consult a healthcare professional for an accurate diagnosis.**'. After the disclaimer, provide comprehensive information about potential related conditions, detailed wellness tips, and list 3-5 clarifying questions the user could consider discussing with a doctor. Provide a thorough but easy-to-understand response."
    analysisPrompt = translation
  } else {
    // Provide analysis directly in the original language to avoid translation truncation
    systemInstruction = `You are a helpful AI Symptom Checker assistant. Respond in ${language}. Your purpose is to provide general health information. You are NOT a doctor and MUST NOT provide a diagnosis. Always begin your response with a clear, bold disclaimer in ${language} about consulting a healthcare professional. After the disclaimer, provide comprehensive information about potential related conditions, detailed wellness tips, and list 3-5 clarifying questions the user could consider discussing with a doctor. Provide a thorough but easy-to-understand response in ${language}.`
    analysisPrompt = combinedSymptoms // Use original symptoms
  }
  
  let analysisResponse: string
  try {
    console.log("Attempting primary analysis with symptoms:", analysisPrompt)
    analysisResponse = await callGeminiApi(analysisPrompt, systemInstruction, 1200)
    console.log("Primary analysis successful")
  } catch (error) {
    console.warn("Primary analysis failed, trying simplified approach:", error)
    // Fallback: Try a simpler analysis
    const simplePrompt = `Provide comprehensive health information for these symptoms in ${language}: ${combinedSymptoms}. Start with disclaimer about consulting a doctor. Provide detailed analysis and recommendations.`
    try {
      analysisResponse = await callGeminiApi(simplePrompt, undefined, 1000)
      console.log("Simplified analysis successful")
    } catch (fallbackError) {
      console.error("Both primary and fallback analysis failed:", fallbackError)
      throw new Error(`Failed to analyze symptoms: ${fallbackError instanceof Error ? fallbackError.message : 'Unknown error'}`)
    }
  }

  // Step 3: Since we generated the response directly in the target language, no translation needed
  let finalResponse: string = analysisResponse
  console.log("Final response length:", finalResponse.length)

  return {
    originalText: combinedSymptoms,
    translatedText: translation,
    detectedLanguage: language,
    analysis: analysisResponse,
    translatedAnalysis: finalResponse
  }
}

export async function generateWellnessGuide(
  englishSymptoms: string, 
  language: string
): Promise<string> {
  const wellnessPrompt = `Based on these symptoms: "${englishSymptoms}", create a comprehensive 3-day wellness guide. This is for general wellness and is NOT medical advice. For each day, provide detailed suggestions for: 1. Hydration tips with specific recommendations. 2. Nutritious meal ideas with ingredients. 3. Gentle activities suitable for the condition. 4. Rest and recovery tips. Start with a disclaimer and provide thorough guidance.`
  
  const wellnessResponse = await callGeminiApi(wellnessPrompt, undefined, 600)

  const translationPrompt = `Translate the following wellness guide into ${language}. Keep all markdown formatting and preserve all details. Text: "${wellnessResponse}"`
  
  return await callGeminiApi(translationPrompt, undefined, 600)
}

export async function findSpecialistTypes(
  englishSymptoms: string, 
  language: string
): Promise<string> {
  const specialistPrompt = `A person in Durgapur, West Bengal, India has health concerns based on these symptoms: "${englishSymptoms}". List 3-5 types of medical specialists they could consider consulting. For each specialist type, provide detailed explanation of what they do, what conditions they treat, and when to consult them. IMPORTANT: Do NOT recommend specific doctors, hospitals, or clinics. This is for informational purposes only. Provide comprehensive information.`
  
  const specialistResponse = await callGeminiApi(specialistPrompt, undefined, 500)
  
  const translationPrompt = `Translate the following list of medical specialist types into ${language}. Keep all formatting and preserve all details. Text: "${specialistResponse}"`
  
  return await callGeminiApi(translationPrompt, undefined, 500)
}